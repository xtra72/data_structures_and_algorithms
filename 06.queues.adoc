= Queue(큐)

* 먼저 들어온 것이 먼저 나가는 선입선출(FIFO)을 구현한 컬렉션
* 접근 가능한 유일한 객체가 삽입된 첫 번째 객체
* 예
** 대기 줄

== 큐의 연산

* add - 큐에 요소 추가
* element - 큐의 맨 앞 요소 참조
* remove - 큐의 맨 앞 요소 제거

image::./images/queue.svg[align=center]

== 간단한 Queue Interface

* 큐의 기본 연산으로만 정의

[source,java]
----
public interface Queue {
        public void add(int element);
        public int element();
        public int remove();
}
----

== 배열을 이용한 큐 구현

* 큐에 입력되는 요소들을 배열을 이용해 관리
** 인덱스를 이용한 접근으로 빠르고 간편
* 초기 배열 크기 지정
** 배열이 고정될 경우, 배열 크기 내에서만 사용 가능

=== 예제 6.1. 배열을 이용해 ArrayQueue를 작성하고, 테스트하세요.

* 큐내의 요소 관리를 위한 자료 구조로 배열 사용
* toString()을 이용해 큐 출력

[source,java]
----

public class ArrayQueue implements Queue {
    int[] array;
    int head;
    int tail;


    public ArrayQueue(int size) {
        //...
    }

    @Override
    public void add(int element) {
        //...
    }

    @Override
    public int element() {
        //...
    }

    @Override
    public int remove() {
        //...
    }

    @Override
    public String toString() {
        //...
    }

    public static void main(String[] args) {
        Queue queue = new ArrayQueue(5);

        System.out.println("queue : " + queue);
        queue.add(1);
        System.out.println("queue : " + queue);
        queue.add(2);
        System.out.println("queue : " + queue);
        queue.add(3);
        System.out.println("queue : " + queue);
        queue.add(4);
        System.out.println("queue : " + queue);
        queue.add(5);
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
    }
}
----

결과는 다음과 같다.

[source,console]
----
queue : []
queue : [ 1]
queue : [ 1,  2]
queue : [ 1,  2,  3]
queue : [ 1,  2,  3,  4]
queue : [ 1,  2,  3,  4,  5]
queue : [ 2,  3,  4,  5]
queue : [ 3,  4,  5]
queue : [ 4,  5]
queue : [ 5]
queue : []
----

=== 문제 6.1. 앞에서 작성한 ArrayQueue를 이용해 요청되는 추가 기능을 작성하고, 테스트하세요.

* 큐에서 가지고 있는 요소 수를 알 수 있는 size()
* 큐가 비워져 있는 확인 가능한 isEmpty()
* 큐에 설정된 배열이 다 찼을 경우,
** 배열의 크기 변경

[source,java]
----
public class ArrayQueue2 implements Queue {
    int[] array;
    int head;
    int tail;

    public ArrayQueue2(int size) {
        //...
    }

    public int size() {
        //...
    }

    public boolean isEmpty() {
        //...
    }

    @Override
    public void add(int element) {
        //...
    }

    @Override
    public int element() {
        //...
    }

    @Override
    public int remove() {
        //...
    }

    @Override
    public String toString() {
        //...
    }

    public static void main(String[] args) {
        ArrayQueue2 queue = new ArrayQueue2(2);

        System.out.printf("%15s | %7s | %4s | %s%n",
                "Command", "isEmpty", "Size", "Elements");
        queue.add(1);
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.add(1)",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.add(2);
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.add(2)",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.add(3);
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.add(3)",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.add(4);
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.add(4)",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.add(5);
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.add(5)",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.remove();
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.remove()",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.remove();
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.remove()",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.remove();
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.remove()",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.remove();
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.remove()",
                queue.isEmpty(), queue.size(), queue.toString());
        queue.remove();
        System.out.printf("%15s | %7s | %4d | %s%n", "queue.remove()",
                queue.isEmpty(), queue.size(), queue.toString());
    }
}
----

결과는 다음과 같다.

[source,console]
----
        Command | isEmpty | Size | Elements
   queue.add(1) |   false |    1 | [ 1]
   queue.add(2) |   false |    2 | [ 1,  2]
   queue.add(3) |   false |    3 | [ 1,  2,  3]
   queue.add(4) |   false |    4 | [ 1,  2,  3,  4]
   queue.add(5) |   false |    5 | [ 1,  2,  3,  4,  5]
 queue.remove() |   false |    4 | [ 2,  3,  4,  5]
 queue.remove() |   false |    3 | [ 3,  4,  5]
 queue.remove() |   false |    2 | [ 4,  5]
 queue.remove() |   false |    1 | [ 5]
 queue.remove() |    true |    0 | []
----

=== 문제 6.2. 앞에서 구현한 ArrayQueue2에는 치명적인 문제가 있다. 확인하고 수정한 후 테스트하세요.

* 아래의 과정 수행 후 문제점 확인
** ArrayQueue2에 배열 크기를 알 수 있는 getCapacity() 메서드 추가
** 요소 하나를 넣었다 빼기를 반복
* 문제점은? 해결하기 위한 방법은?
** link:https://en.wikipedia.org/wiki/Circular_buffer[Circular Buffer(링버퍼)]

[source,java]
----
class Problem6_2 {
    public static void main(String[] args) {
        ArrayQueue2 queue2 = new ArrayQueue2(2);
        ArrayQueue3 queue3 = new ArrayQueue3(2);

        System.out.printf("%10s | %10s | %10s | %10s | %10s | %10s%n",
                "queue2", "Capacity", "Elements", "queue3", "Capacity", "Elements");
        for (int i = 0; i < 10; i++) {
            System.out.printf("%10s | %10d | %10s | %10s | %10d | %10s%n",
                    "queue2", queue2.getCapacity(), queue2.toString(),
                    "queue3", queue3.getCapacity(), queue3.toString());
            queue2.add(i);
            queue3.add(i);
            System.out.printf("%10s | %10d | %10s | %10s | %10d | %10s%n",
                    "queue2", queue2.getCapacity(), queue2.toString(),
                    "queue3", queue3.getCapacity(), queue3.toString());
            queue2.remove();
            queue3.remove();
        }
        System.out.printf("%10s | %10d | %10s | %10s | %10d | %10s%n",
                "queue2", queue2.getCapacity(), queue2.toString(),
                "queue3", queue3.getCapacity(), queue3.toString());
    }
}

----

결과는 아래와 같다.

[source,console]
----
    queue2 |   Capacity |   Elements |     queue3 |   Capacity |   Elements
    queue2 |          2 |         [] |     queue3 |          2 |         []
    queue2 |          2 |        [0] |     queue3 |          2 |        [0]
    queue2 |          2 |         [] |     queue3 |          2 |         []
    queue2 |          2 |        [1] |     queue3 |          2 |        [1]
    queue2 |          2 |         [] |     queue3 |          2 |         []
    queue2 |          7 |        [2] |     queue3 |          2 |        [2]
    queue2 |          7 |         [] |     queue3 |          2 |         []
    queue2 |          7 |        [3] |     queue3 |          2 |        [3]
    queue2 |          7 |         [] |     queue3 |          2 |         []
    queue2 |          7 |        [4] |     queue3 |          2 |        [4]
    queue2 |          7 |         [] |     queue3 |          2 |         []
    queue2 |          7 |        [5] |     queue3 |          2 |        [5]
    queue2 |          7 |         [] |     queue3 |          2 |         []
    queue2 |          7 |        [6] |     queue3 |          2 |        [6]
    queue2 |          7 |         [] |     queue3 |          2 |         []
    queue2 |         12 |        [7] |     queue3 |          2 |        [7]
    queue2 |         12 |         [] |     queue3 |          2 |         []
    queue2 |         12 |        [8] |     queue3 |          2 |        [8]
    queue2 |         12 |         [] |     queue3 |          2 |         []
    queue2 |         12 |        [9] |     queue3 |          2 |        [9]
    queue2 |         12 |         [] |     queue3 |          2 |         []
----

* 배열 크기가 계속해서 증가되는 문제 해결
* 모든 문제가 해결되었나?
** 프로그램 시작과 함께 요소의 삽입이 10000번 발생한 후

== Linked data를 이용한 큐 구현

배열을 이용해 큐를 구현할 경우 다음과 같은 문제들이 발생할 수 있다.

* 인덱스 증가로 인한 배열 공간 낭비
** 순환 버퍼를 이용해 해결
* 요소 유입의 급속한 증가에 따라 큰 배열 할당 후 적은 유입

=== 예제 6.2. Linked data를 이용해 LinkedQueue를 작성하고, 테스트하세요.

* 앞에서 정의한 Node 클래스 사용
+
[source,java]
----
package example.ch6;

public class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
    }

    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    public int getData() {
        return data;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}
----
* 앞에서 정의한 Queue를 linked data를 이용해 구현
+
[source,java]
----

public class LinkedQueue implements Queue {
    Node head;

    public LinkedQueue(int size) {
        //...
    }

    @Override
    public void add(int element) {
        //...
    }

    @Override
    public int element() {
        //...
    }

    @Override
    public int remove() {
        //...
    }

    @Override
    public String toString() {
        //...
    }

    public static void main(String[] args) {
        Queue queue = new LinkedQueue();

        System.out.println("queue : " + queue);
        queue.add(1);
        System.out.println("queue : " + queue);
        queue.add(2);
        System.out.println("queue : " + queue);
        queue.add(3);
        System.out.println("queue : " + queue);
        queue.add(4);
        System.out.println("queue : " + queue);
        queue.add(5);
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
        queue.remove();
        System.out.println("queue : " + queue);
    }
}
----

=== 문제 6.3. 앞에서 작성한 LinkedQueue를 이용해 요청되는 추가 기능을 작성하고, 테스트하세요.

* 큐에서 가지고 있는 요소 수를 알 수 있는 size()
* 큐가 비워져 있는 확인 가능한 isEmpty()


== 효율적 자원 관리

* ArrayQueue는
** 큐에서 관리해야 하는 요소 수가 제한적일 경우, 일정 크기의 배열을 이용해 빠르게 삽입/제거 가능
** 그렇지 않으며, 빈번한 배열의 복사 또는 필요 이상의 공간 사용의 문제
* LinkedQueue는
** 큐에서 관리해야 하는 요소 수가 가변적일 경우, 필요한 공간만 확보 후 해제함으로써 효율적 메모리 활용
** 시스템에 따라 빈번한 메모리 할당/해제가 문제될 수 있음
*** 메모리 조각화

=== 문제 6.4. ArrayQueue3와 LinkedQueue를 이용해 두 큐의 자원 활용에 대해 비교해 보자.

다음 두 경우에 대해 수행 시간을 비교해 보자.

* Case 1
** ArrayQueue3의 초기 크기를 5, 배열 증가량을 5로 생성
** 100000개의 요소를 생성하여 넣고
** 100000개를 삭제
** LinkedQueue2 생성
** 100000개의 요소를 생성하여 넣고
** 100000개를 삭제

* Case 2
** ArrayQueue3의 초기 크기를 5, 배열 증가량을 5로 생성
** 1개의 요소를 생성하여 넣고
** 1개의 요소를 삭제하는 과정을 1000000번 반복
** LinkedQueue2 생성
** 1개의 요소를 생성하여 넣고
** 1개의 요소를 삭제하는 과정을 1000000번 반복

결과는 아래와 같다.
[source,console]
----
Case 1
ArrayQueue3 : 100000 loops = 558 ms
LinkedQueue2 : 100000 loops = 6 ms
Case 2
ArrayQueue3 : 1000000 loops = 14 ms
LinkedQueue2 : 1000000 loops = 8 ms
----

**참고**

* System.currentTimeMills()
** 이용해 현재 시스템 시간을 얻어 옴
** 1970/01/01 00:00:00(link:https://en.wikipedia.org/wiki/UTC%2B00:00[UTC]) 부터의 시간을 밀리초 단위로 계산


== 리뷰 질문

1. 큐가 FIFO 구조로 불리는 이유는 무엇인가요?
2. 큐를 다음과 같이 부르는 것이 의미가 있을까요?
a. LILO 구조?
b. FILO 구조?
3. 연속적인 데이터 구조를 이용한 큐의 구현과 연결 구조를 이용한 큐 구현의 장단점은 무엇인가요?
