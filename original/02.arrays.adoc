:stem: latexmath

= Arrays

An _array_ is an object that consists of a sequence of elements that are numbered stem:[0, 1, 2, \cdots] The element numbers are called _index numbers_. Array elements can be accessed by their index numbers using the subscript operator [], as a[0], a[1], a[2], and so on.

Arrays are widely used because they are so efficient.

== PROPERTIES OF ARRAYS

Here are the main properties of arrays in Java:

1.	Arrays are objects.
2.	Arrays are created dynamically (at run time).
3.	Arrays may be assigned to variables of type Object.
4.	Any method of the Object class may be invoked on an array.
5.	An array object contains a sequence of variables.
6.	The variables are called the components or elements of the array.
7.	If the component type is T, then the array itself has type T[].
8.	An array type variable holds a reference to the array object.
9.	The component type may itself be an array type.
10.	An array element is a component whose type is not an array type.
11.	An element’s type may be either primitive or reference.
12.	The length of an array is its number of components.
13.	An array’s length is set when the array is created, and it cannot be changed.
14.	An array’s length can be accessed as a public final instance variable.
15.	Array index values must be integers in the range 0...length – 1.
16.	An ArrayIndexOutOfBoundsException is thrown if Property 15 is violated.
17.	Variables of type short, byte, or char can be used as indexes.
18.	Arrays can be duplicated with the Object.clone() method.
19.	Arrays can be tested for equality with the Arrays.equals() method.
20.	Array objects implement Cloneable and java.io.Serializable.

Property 3 follows from Property 1. Although array types are not classes, they behave this way as extensions of the Object class. Property 7 shows that array types are not the same as class types. They are, in fact, derived types: For every class type T there is a corresponding array type T[]. Also, for each of the eight primitive types, the corresponding array type exists.

Property 9 allows the existence of arrays of arrays. Technically, Java allows multidimensional arrays only with primitive types. But for objects, an array of arrays is essentially the same thing. Since arrays themselves are objects, an array of arrays is an array of objects, and some of those component objects could also be nonarrays. (See Example 2.1.)

Note that a consequence of Property 13 is that changing a reference component value to null has no effect upon the length of the array; null is still a valid value of a reference component.

=== EXAMPLE 2.1 Some Array Definitions

Here are some valid array definitions:
[source,java]
----
1	public class ArrayDefs {
2	    public static void main(String[] args) {
3	        float x[];
4	        x = new float[100];
5	        args = new String[10];
6	        boolean[] isPrime = new boolean[1000];
7	        int fib[] = {0, 1, 1, 2, 3, 5, 8, 13};
8	        short[][][] b = new short[4][10][5];
9	        double a[][] = {{1.1,2.2}, {3.3,4.4}, null, {5.5,6.6}, null};
10	        a[4] = new double[66];
11	        a[4][65] = 3.14;
12	        Object[] objects = {x, args, isPrime, fib, b, a};
13	    }
14	}
----

Line 3 declares x[] to be an array of floats but does not allocate any storage for the array. Line 4 defines x[] to have 100 float components.

Line 5 declares args[] to be an array of 10 String objects. Note the two different (equivalent) ways to declare an array: The brackets may be a suffix on the type identifier or on the array identifier. Line 5 defines args[] to have 10 String components.

Line 6 defines isPrime[] to be an array of 1000 boolean variables.

Line 7 defines fib[] to be an array of 8 ints, initializing them to the 8 values listed. So for example, fib[4] has the value 3, and fib[7] has the value 13.

Line 8 defines b[][][] to be a three-dimensional array of 4 components, each of which is a twodimensional array of 10 components, each of which is a one-dimensional array of 5 component elements of type short.

Line 9 defines a[ ][ ] to be an array of five components, each of which is an array of elements of type double. Only three of the five component arrays are allocated. Then line 10 allocates a 66-element array of doubles to a[4], and line 11 assigns 3.14 to its last element.

Line 12 defines the array objects to consist of six components, each of which is itself an array. The components of the first four component arrays are elements (nonarrays). But the components of the components b and a are not elements because they are also arrays. The actual elements of the objects array include 2, 5, and 13 (components of the component fib), null (components of the component a), and 2.2 and 3.14 (components of the components of the component a).

The array a[ ][ ] defined in Example 2.1 is called a ragged array because it is a two-dimensional array with rows of different lengths.
The element type of an array in Java can be a primitive type, a reference type, or an array type. The simplest, of course, are arrays of primitive type elements, such as x[ ], isPrime[ ], and fib[ ] in Example 2.1. These are arrays that can be sorted.



== DUPLICATING AN ARRAY

Since it is an object, an array can be duplicated by invoking the Object.clone() method, as shown in Example 2.2.

=== EXAMPLE 2.2 Duplicating an Array

[source,java]
----
15	public class DuplicatingArrays {
16	    public static void main(String[] args) {
17	        int[] a = {22, 44, 66, 88};
18	        print(a);
19	        int[] b = (int[])a.clone(); // duplicate a[] in b[]
20	        print(b);
21	        String[] c = {"AB", "CD", "EF"};
22	        print(c);
23	        String[] d = (String[])c.clone(); // duplicate c[] in d[]
24	        print(d);
25	        c[1] = "XYZ"; // change c[], but not d[]
26	        print(c);
27	        print(d);
28	    }
29
30	    public static void print(int[] a) {
31	        System.out.printf("{%d", a[0]);
32	        for (int i = 1; i < a.length; i++) {
33	            System.out.printf(", %d", a[i]);
34	        }
35	        System.out.println("}");
36	    }
37
38	    public static void print(Object[] a) {
39	        System.out.printf("{%s", a[0]);
40	        for (int i = 1; i < a.length; i++) {
41	            System.out.printf(", %s", a[i]);
42	        }
43	        System.out.println("}");
44	    }
45	}
----

The output is:

[source,console]
----
{22, 44, 66, 88}
{22, 44, 66, 88}
{AB, CD, EF}
{AB, CD, EF}
{AB, XYZ, EF}
{AB, CD, EF}
----

The array a[ ] contains four int elements. The array b[ ] is a duplicate of a[ ]. Similarly, the array d[ ] is a duplicate of the array c[ ], each containing three String elements. In both cases, the duplication is obtained by invoking the clone() method. Since it returns a reference to an Object, it must be cast to the array type being duplicated, int[ ] or String[ ].

The last part of the example shows that the cloned array d[ ] is indeed a separate copy of c[ ]: Changing c[1] to "XYZ" has no effect upon the value "CD" of d[1].


=== THE java.util.Arrays CLASS

Java includes a special “utility” class for processing arrays. The name of this class is Arrays, and it is defined in the java.util package.

=== EXAMPLE 2.3 Using the java.util.Arrays Class

This program imports the Arrays class from the java.util package to access the sort(), binarySearch(), fill(), and equals() methods. It also imports the static print() method from Example 2.2.

[source,java]
----
1	import java.util.Arrays;
2
3	public class TestArrays {
4	    public static void main(String[] args) {
5	        int[] a = {44, 77, 55, 22, 99, 88, 33, 66};
6	        print(a);
7	        Arrays.sort(a);
8	        print(a);
9	        int k = Arrays.binarySearch(a, 44);
10	        System.out.printf("Arrays.binarySearch(a, 44): %d%n", k);
11	        System.out.printf("a[%d]: %d%n", k, a[k]);
12	        k = Arrays.binarySearch(a, 45);
13	        System.out.printf("Arrays.binarySearch(a, 45): %d%n", k);
14	        int[] b = new int[8];
15	        print(b);
16	        Arrays.fill(b, 55);
17	        print(b);
18	        System.out.println("Arrays.equals(a,b): " + Arrays.equals(a,b));
19	    }
20	}
----

The output is

[source,console]
----
44 77 55 22 99 88 33 66
22 33 44 55 66 77 88 99
Arrays.binarySearch(a, 44): 2
a[2]: 44
Arrays.binarySearch(a, 45): -4
0 0 0 0 0 0 0 0
55 55 55 55 55 55 55 55
Arrays.equals(a,b): false
----

The array a[ ] is created and printed at lines 5–6. At line 7, the call Arrays.sort(a) sorts the elements of the array, putting them in ascending order, as we can see from the output from line 8.

At line 9, the Arrays.binarySearch() method is invoked. The second argument, 44, is the search target. The method returns the index 2, which is assigned to k at line 9. Line 11 verifies that 44 is indeed the value of a[2].

The method is invoked again at line 13, this time searching for the target 45. The value is not found in the array, so the method returns a negative number, k = 04. When this happens, the index i = -k - 1 will be the position in the array where the target element should be inserted to maintain the ascending order of the array. Note that, in this case, i = -k - 1 = 3, and 45 should be inserted at a[3] since there are three elements in the array that are less than 45.

The output from line 17 shows how the Arrays.fill() method works: It filled the eight-element array b[ ] with the argument 55.

Finally, line 18 shows how the Arrays.equals() method works. It will return true only if the two arrays have the same element type (as a[ ] and b[ ] do: int[ ]), the same length (as a[ ] and b[ ] do: 8), and the same values at each element (a[ ] and b[ ] do not).

The java.util.Arrays class is outlined in more detail in page 95.

== THE SEQUENTIAL SEARCH ALGORITHM

The _sequential search_ (also called the _linear search_) is the simplest search algorithm. It is also the least efficient. It simply examines each element sequentially, starting with the first element, until it finds the key element or it reaches the end of the array.

If you were looking for someone on a moving passenger train, you would use a sequential search.

Here is the _sequential search algorithm_:

(Postcondition: either the index i is returned where si = x, or -1 is returned.)

1.	Repeat steps 2-3, for i = 0 to n - 1.
2.	(Invariant: none of the elements in the subsequence stem:[\{s_{0}...s_{i-1}\}] is equal to x.)
3.	If stem:[s_{i} = x], return i .
4.	Return -1.

It is implemented in Example 2.4.

=== EXAMPLE 2.4 The Sequential Search

[source,java]
----
1	public class TestBinarySearch {
2	    public static void main(String[] args) {
3	        int[] a = {22, 33, 44, 55, 66, 77, 88, 99};
4	        ch02.ex02.DuplicatingArrays.print(a);
5	        System.out.println("search(a, 44): " + search(a, 44));
6	        System.out.println("search(a, 50): " + search(a, 50));
7	        System.out.println("search(a, 77): " + search(a, 77));
8	        System.out.println("search(a, 100): " + search(a, 100));
9	    }
10
11	    public static int search(int[] a, int x) {
12	        // POSTCONDITIONS: returns an integer i;
13	        //	if i >= 0, then a[i] == x; otherwise x is not in a[];
14	        for (int i=0; i<a.length; i++) {	// step 1
15	            // INVARIANT: x is not among a[0]...a[i-1] // step 2
16	            if (a[i] == x) {	// step 3
17	                return i;
18	            }
19	        }
20	        return -1;	// step 4
21	    }
22	}
----

The output is:

[source,console]
----
{22, 33, 44, 55, 66, 77, 88, 99}
search(a, 44): 2
search(a, 50): -1
search(a, 77): 5
search(a, 100): -1
----

The search() method returns the index of the target x: search(a, 44) returns 2, because a[2] = 44; search(a, 77) returns 5, because a[5] = 77. The method returns –1 when the target is not in the array: search(a, 50) returns –1, because 50 is not in the array.

**The sequential search is correct**. This means that it works. The following argument is a proof of that fact.

If n = 0, then the sequence is empty and the loop does not execute at all. Only step 4 executes, immediately returning –1. This satisfies the postconditions: x cannot equal any of the elements because there aren’t any.

If n = 1, then the loop iterates only once, with i = 0. On that iteration, either stem:[s_{0} = x] or stem:[s_{0} \neq x]. If stem:[s_{0} = x], then 0 is returned and the postcondition is satisfied. If stem:[s_{0} \neq x], then the loop terminates, step 4 executes, and –1 is returned, and that satisfies the postcondition because the single element of the sequence is not equal to x.

Suppose n > 1. We want to apply the First Principle of Mathematical Induction to deduce that the loop invariant must be true on every iteration of the loop. (See page 321.) That requires the verification of the invariant on the first iteration and the deduction of the invariant on iteration i from the corresponding invariant on iteration i –1.

On the first iteration of the loop, i = 0, and the loop invariant in step 2 is true “vacuously” because the subsequence stem:[\{s_{0} \cdots s_{i-1}\}] is empty. Then in step 3, either stem:[s_{0} = x] or stem:[s_{0} \neq x]. If stem:[s_{0} = x], then 0 is returned and the postcondition is satisfied. If stem:[s_{0} \neq x\], then the loop continues on to a second iteration. Then i = 1, and the loop invariant in step 2 is again true because the subsequence stem:[\{s_{0}...s_{i–1}\} = \{s_{0}\} and s_{0} \* x].

Suppose now that on iteration i – 1, the loop invariant is true; that is, none of the elements in the subsequence stem:[\{s_{0} \cdots s_{i-1}\}] is equal to x. If the loop continues on to the next iteration, then the condition stem:[s_{i} = x] at step 3 was not true. Thus, stem:[s_{i} * x]. Therefore, none of the elements in the subsequence stem:[\{s_{0} \cdots s_{i} \}] is equal to x, which is the loop invariant on the stem:[i]th iteration.

The sequential search runs in stem:[O(n)] time. This means that, on average, the running time is proportional to the number of elements in the array. So if everything else is the same, then applying the sequential search to an array twice as long will take about twice as long, on average. The following argument is a proof of that fact.
If x is in the sequence, say at stem:[x = s_{i}] with i < n, then the loop will iterate i times. In that case, the running time is proportional to i, which is stem:[O(n)] since i < n. If x is not in the sequence, then the loop will iterate n times, making the running time proportional to n, which is stem:[O(n)].

== THE BINARY SEARCH ALGORITHM

The binary search is the standard algorithm for searching through a sorted sequence. It is much more efficient than the sequential search, but it does require that the elements be in order. It repeatedly divides the sequence in two, each time restricting the search to the half that would contain the element.

You might use the binary search to look up a word in a dictionary. Here is the binary algorithm:

(Precondition: stem:[s = \{s_{0}, s_{1}, \cdots, s_{n-1}\}] is a sorted sequence of n values of the same type as x.) (Postcondition: either the index i is returned where stem:[s_{i} = x], or -1 is returned.)

1.	Let ss be a subsequence of the sequence s, initially set equal to s.
2.	If the subsequence ss is empty, return -1.
3.	(Invariant: If x is in the sequence s, then it must be in the subsequence ss.)
4.	Let si be the middle element of ss.
5.	If si = x, return its index i .
6.	If si < x, repeat steps 2-7 on the subsequence that lies above stem:[s_i] .
7.	Repeat steps 2-7 on the subsequence of ss that lies below si. It is implemented in Example 2.5.

=== EXAMPLE 2.5 The Binary Search

[source,java]
----
1	public class TestBinarySearch {
2	    public static void main(String[] args) {
3	        int[] a = {22, 33, 44, 55, 66, 77, 88, 99};
4	        ch02.ex02.DuplicatingArrays.print(a);
5	        System.out.println("search(a, 44): " + search(a, 44));
6	        System.out.println("search(a, 50): " + search(a, 50));
7	        System.out.println("search(a, 77): " + search(a, 77));
8	        System.out.println("search(a, 100): " + search(a, 100));
9	    }
10
11	    public static int search(int[] a, int x) {
12	        // POSTCONDITIONS: returns i;
13	        //	if i >= 0, then a[i] == x; otherwise i == -1;
14	        int lo = 0;
15	        int hi = a.length;
16	        while (lo < hi) {	        // step 1
17	            // INVARIANT: if a[j]==x then lo <= j < hi; // step 3
18	            int i = (lo + hi)/2;	// step 4
19	            if (a[i] == x) {
20	                return i;	        // step 5
21	            } else if (a[i] < x) {
22	                lo = i+1;	        // step 6
23	            } else {
24	                hi = i;	            // step 7
25	            }
26	        }
27	        return -1;	                // step 2
28	    }
29	}
----

The output is the same as in Example 2.4.

The binary search is correct. The loop invariant is true on the first iteration because the current subsequence is the same as the original sequence. On every other iteration, the current subsequence was defined in the preceding iteration to be the half of the previous subsequence that remained after omitting the half that did not contain x. So if x was in the original sequence, then it must be in the current subsequence. Thus the loop invariant is true on every iteration.

On each iteration, either i is returned where si = x, or the subsequence is reduced by more than 50 percent. Since the original sequence has only a finite number of elements, the loop cannot continue indefinitely. Consequently, the algorithm terminates either by returning i from within the loop or at step 6 or step 7 where –1 is returned. If i is returned from within the loop, then stem:[s_{i} = x]. Otherwise, the loop terminates when hi < lo; that is, when the subsequence is empty. In that case we know by the loop invariant that si is not in the original sequence.

The binary search runs in O(lgn) time. This means that, on average, the running time is proportional to the logarithm of the number of elements in the array. So if everything else is the same, if it takes an average of T milliseconds to run on an array of n elements, then will take an average of 2T milliseconds to run on an array of stem:[n^{2}] elements. For example, if it takes 3 ms to search 10,000 elements, then it should take about 6 ms to search 100,000,000 elements! The following argument is a proof of that fact.

Each iteration of the loop searches a subarray that is less than half as long as the subarray on the previous iteration. Thus the total number of iterations is no more than the number of times that the length n can be divided by 2. That number is lg n. And the total running time is roughly proportional to the number of iterations that the loop makes.

== Review Questions

1. What is the difference between a component and an element of an array?
2. What does it mean to say that Java does not allow multidimensional arrays?
3. What is an ArrayIndexOutOfBoundsException exception, and how does its use distinguish Java from other languages such as C and C++?
4. What types are valid for array indexes?
5. What’s wrong with this definition:
Arrays arrays = new Arrays();
6. What is the simplest way to print an array of objects?
7. If the binary search is so much faster than the sequential search, why would the latter ever be used?
8. What happens if the sequential search is applied to an element that occurs more than once in the array?
9. What happens if the binary search is applied to an element that occurs more than once in the array?

== Problems

1. Run a test program to see how the Arrays.fill() method handles an array of objects.
2. If the sequential search took 50 ms to run on an array of 10,000 elements, how long would you expect it to take to run on an array of 20,000 elements on the same computer?
3. If the binary search took 5 ms to run on an array of 1,000 elements, how long would you expect it to take to run on an array of 1,000,000 elements on the same computer?
4. The interpolation search is the same as the binary search except that in step 4 the element si is chosen so that the proportion of elements less than si in the subsequence ss equals the proportion that would be expected in a uniform distribution. For example, looking up the name “Byrd” in a phone book of 2,600 pages, one would open first near page 200 because one would expect about 2/26 of all the names to precede it. The interpolation search can be shown to run in O(lglgn) time. If it took 5 ms to run on an array of 1,000 elements, how long would you expect it to take to run on an array of 1,000,000 elements on the same computer?
5. Run a test driver for the binary search method in Example 2.5 on page 32 on an array of 10,000 elements and count the number of iterations.
6. Write and test this method:
+
[source,java]
----
boolean isSorted(int[] a)
// returns true iff a[0] <= a[1] <= ... <= a[a.length-1]
----
7. Write and test this method:
+
[source,java]
----
int minimum(int[] a)
// returns the minimum element of a[]
----
8. Write and test this method:
+
[source,java]
----
double mean(double[] a)
// returns the average value of all the elements in a[]
----
9. Write and test this method:
+
[source,java]
----
int[] withoutDuplicates(int[] a)
// returns the specified array after removing all duplicates
----
10. Write and test this method:
+
[source,java]
----
void reverse(int[] a)
// reverses the elements of a[]
----
11. Write and test this method:
+
[source,java]
----
Object[] concatenate(Object[] a, Object[] b)
// returns an array containing all of a[] followed by all of b[]
----
12. Write and test this method:
+
[source,java]
----
void shuffle(Object[] a)
// randomly permutes the elements of a[]
----
13. Write and test this method:
+
[source,java]
----
int[] tally(String string)
// returns an array a[] of 26 integers that count the frequencies
// of the (case insensitive) letters in the given string
----
14. Write and test this method:
+
[source,java]
----
double innerProduct(double[] x, double[] y)
// returns the algebraic inner product (the sum of the component-
// wise products) of the two given arrays as (algebraic) vectors
----
15. Write and test this method:
+
[source,java]
----
double[][] outerProduct(double[] x, double[] y)
// returns the algebraic outer product of the two given arrays
// as (algebraic) vectors: p[i][j] = a[i]*b[j]
----
16. Write and test this method:
+
[source,java]
----
double[][] product(double[][] a, double[][] b)
// returns the matrix product of the two given arrays a matrix:
// p[i][j] = Sum(a[i][k]*b[k][j]:k)
----
17. Write and test this method:
+
[source,java]
----
double[][] transpose(double[][] a)
// returns the transpose ta of the specified array as a matrix:
// ta[i][j] = a[j][i]
----
18. Write and test this method:
+
[source,java]
----
int[][] pascal(int size)
// returns Pascal’s triangle of the given size
----
19. The Sieve of Eratosthenes is an array of boolean elements whose ith element is true if and only if i is a prime number. Use the following algorithm to compute and print a sieve of size 1000:
+
(Precondition: p is an array of n bits.)
(Postcondition: p[i] is true if and only if i is prime.)
 . Initialize p[0] and p[1] to be false, and all other p[i] to be true.
 . Repeat step 3 for each i from 3 to n, incrementing by 2.
 . If there is a prime stem:[\le] the square root of i that divides i, set p[i] false.
20. Repeat Problem 2.19 using a java.util.Vector object.
21. Repeat Problem 2.19 using a java.util.BitSet object.
22.	Define and test a Primes class with these methods:
+
[source,java]
----
public static void setLast(int last)	// sets last
public static void setLast()	// sets last=1
public static void sizeSize(int size) // sets size of bitset
public static void sizeSize()	// sets bitset size=1000
public static boolean isPrime(int n)	// true if n is prime
public static int next()	// next prime after last
public static void printPrimes()	// prints sieve
----
Use the BitSet implementation of the Sieve of Eratosthenes from Problem 2.21. Use these definitions:
+
[source,java]
----
public class Primes {
    private static final int SIZE = 1000;
    private static int size = SIZE;
    private static BitSet sieve = new BitSet(size);
    private static int last = 1;
----
including this static initializer, which implements the Sieve of Eratosthenes:
+
[source,java]
----
static {
    for (int i = 2; i < SIZE; i++) {
        sieve.set(i);
    }
    for (int n = 2; 2*n < SIZE; n++) {
        if (sieve.get(n)) {
            for (int m=n; m*n<SIZE; m++) {
                sieve.clear(m*n);
            }
        }
    }
}
----
23. Add the following method to the Primes class and then test it:
+
[source,java]
----
public static String factor(int n)
// precondition: n > 1
// returns the prime factorization of n;
// example: factor(4840) returns "2*2*2*5*11*11"
----
24. Christian Goldbach (1690–1764) conjectured in 1742 that every even number greater than 2 is the sum of two primes. Write a program that tests the Goldbach conjecture for all even numbers less than 100. Use the Primes class from Problem 2.22. Your first 10 lines of output should look like this:
+
[source,console]
----
4 = 2+2
6 = 3+3
8 = 3+5
10 = 3+7 = 5+5
12 = 5+7
14 = 3+11 = 7+7
16 = 3+13 = 5+11
18 = 5+13 = 7+11
   = 3+17 = 7+13
   = 3+19 = 5+17 = 11+11
----
25. Pierre de Fermat (1601–1665) conjectured that there are infinitely many prime numbers of the form stem:[n = 2^{2^{p}}+1] for some integer stem:[p]. These numbers are called Fermat primes. For example, 5 is a Fermat prime because it is a prime number and it has the form stem:[2^{2^{1}} +1]. Write a program that finds all the Fermat primes that are in the range of the int type. Use the Primes class from Problem 2.22 and the Math.pow() method. Your first 5 lines of output should look like this:
+
[source,console]
----
2^0	+	1	=	3
2^1	+	1	=	5
2^2	+	1	=	17
2^3	+	1	=	257
2^4	+	1	=	65537
----
26. Charles Babbage (1792–1871) obtained the first government grant in history when in 1823 he persuaded the British government to provide £1000 to build his difference engine. In his grant proposal, Babbage gave the formula x 2 + x + 41 as an example of a function that his computer would tabulate. This particular function was of interest to mathematicians because it produces an unusual number of prime numbers.Primes that have this form n = x 2 + x + 41 for some integer x could be called Babbage primes. Write a program that finds all the Babbage primes that are less than 10,000. Use the Primes class from Problem 2.22. Your first five lines of output should look like this:
+
[source,console]
----
0	41	is	prime
1	43	is	prime
47	is	prime
3	53	is	prime
4	61	is	prime
----
27. Two consecutive odd integers that are both prime are called twin primes. The twin primes conjecture is that there are infinitely many twin primes. Write a program that finds all the twin primes that are less than 1000. Use the Primes class from Problem 2.22. Your first five lines of output should look like this:
+
[source,console]
----
3	5
5	7
11	13
17	19
	31
----
28. Test the conjecture that there is at least one prime between each pair of consecutive square numbers. (The square numbers are 1, 4, 9, 16, 25, . . .). Use the Primes class from Problem 2.22. Your first five lines of output should look like this:
+
[source,console]
----
1 < 2 < 4
4 < 5 < 9
9 < 11 < 16
16 < 17 < 25
25 < 29 < 36
----
29. The Minimite friar Marin Mersenne (1588–1648) undertook in 1644 the study of numbers of the form stem:[n = 2^{p} - 1], where p is a prime. He believed that most of these n are also primes, now called Mersenne primes.Write a program that finds all the Mersenne primes for p < 30. Use the Primes class from Problem 2.22. Your first five lines of output should look like this:
+
[source,console]
----
2^2-1 = 3 is prime
3	2^3-1 = 7 is prime
5	2^5-1 = 31 is prime
7	2^7-1 = 127 is prime
11	2^11-1 = 2047 is not prime
----
30	A number is said to be palindromic if it is invariant under reversion; that is, the number is the same if its digits are reversed. For example, 3456543 is palindromic. Write a program that checks each of the first 10,000 prime numbers and prints those that are palindromic. Use the Primes class from Problem 2.22.

== Answers to Review Questions

1.	An array component can be any type: primitive, reference, or array. An array element is a component that is not itself an array type. So in a two-dimensional array a[][], the components of a[] are its row arrays, and the elements of a[][] are double variables.
2.	A multidimensional array is one that has more than one index. A Java array has only one index variable. However, since a components indexed by that variable can itself be an array (with an index), the original array appears to have more than one index.
3.	An ArrayIndexOutOfBoundsException object is an exception that gets thrown whenever a value less than 0 or greater than or equal to the array’s length is attempted to be used as an index on the array. This give the programmer some control over the consequences of such a run-time error. In languages such as C++, such a run-time error normally causes the program to crash.
4.	An array index can have type byte, char, short, or int.
5.	The Array class cannot be instantiated because its constructor is declared private.
6.	The simplest way to print an array of objects is to pass it to the Arrays.toList() method which produces a List object that can be printed directly with the System.out.println() method.
7.	The binary search will probably not work unless the sequence is sorted first.
8.	If the sequential search is applied to an element that occurs more than once in an array, it will return the index of the one that is closest to the beginning of the array.
9.	If the binary search is applied to an element that occurs more than once in an array, it could return the index of any one of them. It depends upon how close their indexes are to multiples of midpoints of subintervals. For example, if the binary search is applied in an array of 10,000 elements, searching for a value that is repeated at locations 0–99, the search would return the index 77 on the 7th iteration.

== Solutions to Problems

1.	public class TestFill {
public static void main(String[] args) { Object[] a = new Object[4]; Arrays.fill(a, new Date()); ch02.ex02.DuplicatingArrays.print(a); Arrays.fill(a, 22); ch02.ex02.DuplicatingArrays.print(a); Arrays.fill(a, "Yo!"); ch02.ex02.DuplicatingArrays.print(a);
}
2.	The sequential search runs in linear time, which means that the time is proportional to the number of elements. So an array with twice as many elements would take twice as long to process: 20 ms.
3.	The binary search runs in logarithmic time, so squaring the size of the problem should only double its running time. So an array with 10002 elements would take twice as long to process: 10 ms.
4.	The interpolation search runs in hyperlogarithmic time, so squaring the size of the problem should have no appreciable effect on its running time. So an array with 1,000,000 elements would also take about 2 ms to process.
5. _
+
[source,java]
----
public class TestBinarySearch {
    private static final int SIZE = 10000;
    private static final int START = 0;
    private static final int RANGE = 10000;
    private static Random random = new Random();
    private static int count = 0;

    public static void main(String[] args) {
        int[] a = new int[SIZE];
        load(a, START, RANGE);
        Arrays.sort(a);
        search(a, random.nextInt(10000));
        System.out.println(count + " iterations");
    }

    public static void load(int[] a, int start, int range) {
        for (int i = 0; i < a.length; i++) {
            a[i] = start + random.nextInt(range); // random 5-digit numbers
        }
    }

    public static int search(int[] a, int x) {
        int lo = 0;
        int hi = a.length;
        while (lo < hi) {
            ++count;
            int i = (lo + hi)/2;
            if (a[i] == x) {
                return i;
            } else if (a[i] < x) {
                lo = i+1;
            } else {
                hi = i;
            }
        }
        return -1;
    }
}
----
6. _
+
[source,java]
----
boolean isSorted(int[] a) {
    if (a.length < 2) {
        return true;
    }
    for (int i = 1; i < a.length; i++) {
        if (a[i] < a[i-1]) {
            return false;
        }
    }
    return true;
}
----
7. _
+
[source,java]
----
int minimum(int[] a) {
    int min = a[0];
    for (int i = 1; i < a.length; i++) {
        if (a[i] < min) {
            min = a[i];
        }
    }
    return min;
}
----
8. _
+
[source,java]
----
int mean(int[] a) {
    double sum=0.0;
    for (int i = 0; i < a.length; i++) {
        sum += a[i];
        return sum/a.length;
    }
----
9. _
+
[source,java]
----
int[] withoutDuplicates(int[] a) {
    int n = a.length;
    if (n < 2) {
        return a;
    }
    for (int i = 0; i < n-1; i++) {
        for (int j = i+1; j < n; j++) {
            if (a[j] == a[i]) {
                --n;
                System.arraycopy(a, j+1, a, j, n-j);
                --j;
            }
        }
    }
    int[] aa = new int[n];
    System.arraycopy(a, 0, aa, 0, n);
    return aa;
}
----
10. _
+
[source,java]
----
void reverse(int[] a) {
    int n = a.length;
    if (n < 2) {
        return;
    }
    for (int i = 0; i < n/2; i++) {
        swap(a, i, n-i-1);
    }
}
void swap(int[] a, int i, int j) {
    // swaps a[i] with a[j]: int ai = a[i];
    int aj = a[j]; a[i] = aj;
    a[j] = ai;
}
----
11.	_
+
[source,java]
----
Object[] concatenate(Object[] a, Object[] b) {
    Object[] c = new Object[a.length+b.length];
    for (int i = 0; i < a.length; i++) {
        c[i] = a[i];
    }
    for (int i = 0; i < b.length; i++) {
        c[i+a.length] = b[i];
    }
    return c;
}
----
12. _
+
[source,java]
----
void shuffle(Object[] a) {
    Random random = new Random();
    int n = a.length;
    for (int i = 0; i < n; i++) {
        ch02.pr10.TestReverse.swap(a,i,random.nextInt(a.length));
    }
}
----
13. _
+
[source,java]
----
int[] tally(String s) {
    int[] frequency = new int[26];
    for (int i = 0; i < s.length(); i++) {
        char ch = Character.toUpperCase(s.charAt(i));
        if (Character.isLetter(ch)) {
            ++frequency[(int)ch - (int)'A']; // count ch
        }
    return frequency;
}
----
14. _
+
[source,java]
----
double innerProduct(double[] x, double[] y) {
    double sum = 0.0;
    for (int i = 0; i < x.length && i < y.length; i++)
        sum += x[i]*y[i];
    return sum;
}
----
15. _
+
[source,java]
----
double[][] outerProduct(double[] x, double[] y) {
    double[][] z = new double[x.length][y.length];
    for (double xi : x) {
        for (double yj : y) {
            z[i][j] = xi*yj;
        }
    }
    return z;
}
----
16.	_
+
[source,java]
----
double[][] product(double[][] x, double[][] y) {
    double[][] z = new double[x.length][y[0].length];
    for (int i = 0; i < x.length; i++) {
        for (int j = 0; j < y[0].length; j++) {
            double sum = 0.0;
            for (int k = 0; k < x[0].length; k++) {
                sum += x[i][k]*y[k][j];
            }
            z[i][j] = sum;
        }
    }
    return z;
}
----
17.	_
+
[source,java]
----
double[][] transpose(double[][] x) {
    double[][] y = new double[x[0].length][x.length];
    for (int i = 0; i < x[0].length; i++) {
        for (int j = 0; j < x.length; j++) {
            y[i][j] = x[j][i];
        }
    }
    return y;
}
----
18. _
+
[source,java]
----
int[][] pascal(int n) {
    int[][] p = new int[n][n];
    for (int j = 0; j < n; j++) {
        p[j][0] = p[j][j] = 1;
    }
    for (int i = 2; i < n; i++) {
        for (int j = 1; j < i; j++) {
            p[i][j] = p[i-1][j-1] + p[i-1][j];
        }
    }
    return p;
}
----
19. _
+
[source,java]
----
public class TestSieve {
    private static final int SIZE=1000;
    private static boolean[] isPrime = new boolean[SIZE];

    public static void main(String[] args) {
        initializeSieve();
        printSieve();
    }

    private static void initializeSieve() {
        for (int i = 2; i < SIZE; i++) {
            isPrime[i] = true;
        }
        for (int n = 2; 2*n < SIZE; n++) {
            if (isPrime[n]) {
                for (int m = n; m*n <SIZE; m++) {
                    isPrime[m*n] = false;
                }
            }
        }
    }

    private static void printSieve() {
        int n=0;
        for (int i = 0; i < SIZE; i++) {
            if (isPrime[i]) {
                System.out.printf("%5d%s", i, ++n%16==0?"\n":"");
            }
        }
    System.out.printf("%n%d primes less than %d%n", n, SIZE);
    }
}
----
20. _
+
[source,java]
----
public class TestSieve {
    private static final int SIZE=1000;
    private static Vector<Boolean> isPrime = new Vector<Boolean>(SIZE);

    public static void main(String[] args) {
        initializeSieve();
        printSieve();
    }

    private static void initializeSieve() {
        isPrime.add(false); // 0 is not prime
        isPrime.add(false); // 1 is not prime
        for (int i = 2; i < SIZE; i++) {
            isPrime.add(true);
        }

        for (int n = 2; 2*n < SIZE; n++) {
            if ((isPrime.get(n))) {
                for (int m = n; m*n < SIZE; m++) {
                    isPrime.set(m*n, false);
                }
            }
        }
    }

    private static void printSieve() {
        int n=0;
        for (int i = 0; i < SIZE; i++) {
            if (isPrime.get(i)) {
                System.out.printf("%5d%s", i, ++n%16==0?"\n":"");
            }
        }
        System.out.printf("%n%d primes less than %d%n", n, SIZE);
    }
}
----
21. _
+
[source,java]
----
public class TestSieve {
    private static final int SIZE=1000;
    private static BitSet isPrime = new BitSet(SIZE);

    public static void main(String[] args) {
        initializeSieve();
        ch02.pr20.TestSieve.printSieve();
    }

    private static void initializeSieve() {
        for (int i = 2; i < SIZE; i++) {
            isPrime.set(i);
        }
        for (int n = 2; 2*n < SIZE; n++) {
            if (isPrime.get(n)) {
                for (int m = n; m*n <SIZE; m++) {
                    isPrime.clear(m*n);
                }
            }
        }
    }

    private static void printSieve() {
        int n=0;
        for (int i = 0; i < SIZE; i++) {
            if (isPrime.get(i)) {
                System.out.printf("%5d%s", i, ++n%16==0?"\n":"");
            }
        }
        System.out.printf("%n%d primes less than %d%n", n, SIZE);
    }
}
----
22. _
+
[source,java]
----
public class Primes {
    private static final int SIZE = 1000;
    private static int size = SIZE;
    private static BitSet sieve = new BitSet(size);
    private static int last = 1;

    static {
        for (int i=2; i<SIZE; i++) {
            sieve.set(i);
        }
        for (int n=2; 2*n<SIZE; n++) {
            if (sieve.get(n)) {
                for (int m=n; m*n<SIZE; m++) {
                    sieve.clear(m*n);
                }
            }
        }
    }

    public static void setLast(int n) {
        last = n;
    }

    public static void setLast() {
        last = 1;
    }

    public static void setSize(int n) {
        size = n;
    }

    public static void setSize() {
        size = 1000;
    }

    public static boolean isPrime(int n) {
        return sieve.get(n);
    }

    public static int next() {
        while (++last<size) {
            if (sieve.get(last)) {
                return last;
            }
        }
        return -1;
    }

    public static void printPrimes() {
        int n=0;
        for (int i=0; i<SIZE; i++) {
            if (sieve.get(i)) {
                System.out.print((n++%10==0?"\n":"\t")+i);
            }
        }
        System.out.println("\n" + n + " primes less than " + SIZE);
    }
}
----
23. _
+
[source,java]
----
public static String factor(int n) {
    String primes="";
    int p = next();
    while (n > 1) {
        if (n%p==0) {
            primes += (primes.length()==0?"":"*") + p;
            n /= p;
        }
        else p = next();
        if (p == -1) {
            primes += " OVERFLOW"; break;
        }
    }
    setLast();
    return primes;
}
----
24. _
+
[source,java]
----
public class TestGoldbach {
    public static void main(String[] args) {
        Primes.setSize(1000);
        System.out.println("4 = 2+2");
        for (int n = 6; n < 100; n += 2) {
            System.out.print(n);
            for (int p = 3; p <= n/2; p += 2) {
                if (Primes.isPrime(p) && Primes.isPrime(n-p)) {
                    System.out.print(" = "+p+"+"+(n-p));
                }
            }
            System.out.println();
        }
    }
}
----
25. _
+
[source,java]
----
public class TestFermat {
    public static void main(String[] args) {
        Primes.setSize(1000);
        for (int p = 0; p < 5; p++) {
            int n = (int)Math.pow(2,Math.pow(2,p)) + 1;
            if (Primes.isPrime(n)) {
                System.out.println("p = "+p+", n = 2^2^p = "+n);
            }
        }
    }
}
----
26. _
+
[source,java]
----
public class TestBabbage {
    public static void main(String[] args) {
        Primes.setSize(1000);
        for (int x = 0; x < 50; x++) {
            System.out.print(x);
            int n = x*x + x + 41;
            if (Primes.isPrime(n)) {
                System.out.println("\t"+n+" is prime");
            } else {
                System.out.println();
            }
        }
    }
}
----
27. _
+
[source,java]
----
public class TestTwinPrimes {
    public static void main(String[] args) {
        Primes.setSize(1000);
        int n = Primes.next();
        while (n < 0.9*N) {
            if (Primes.isPrime(n+2)) {
                System.out.println(n + "\t" + (n+2));
            }
            n = primes.next();
        }
    }
}
----
28. _
+
[source,java]
----
public class TestSquares {
    public static void main(String[] args) {
        Primes.setSize(1000);
        for (int n = 1; n < 100; n++) {
            for (int i = n*n+1; i < (n+1)*(n+1); i++) {
                if (Primes.isPrime(i)) {
                    System.out.printf("%d < %d < %d%n", n*n, i, (n+1)*(n+1));
                    break;
                }
            }
        }
    }
}
----
29. _
+
[source,java]
----
public class TestMersenne {
    public static void main(String[] args) {
        Primes.setSize(1000);
        for (int p = Primes.next(); p < 30; p = Primes.next()) {
            int n = (int)Math.round(Math.pow(2,p)) - 1;
            System.out.printf("%d\t2^%d-1%d", p, p, n);
            if (Primes.isPrime(n)) {
                System.out.println(" is prime ");
            } else {
                System.out.println(" is not prime ");
            }
        }
    }
}
----
30. _
+
[source,java]
----
boolean isPalindromic(int n) {
    if (n < 0) {
        return false;
    }
    int p10=1;
    // make p10 is the greatest power of 10 that is < n
    while (p10 < n) {
        p10 *= 10;
    }
    p10 /= 10;
    while (n > 9) {
        if (n/p10 != n%10) {
            return false;
        }
        n /= 10;	// remove rightmost digit from n p10 /= 10;
        n %= p10; // remove leftmost digit from n
    }
    return true; // single digit integers are palindromic
}
----