:stem: latexmath

= 배열

배열은 stem:[0, 1, 2, \cdots]와 같이 번호가 매겨진 요소들의 순서로 이루어진 객체입니다. 요소 번호는 _인덱스 번호_라고 합니다. 배열 요소는 대괄호 연산자 []를 사용하여 인덱스 번호로 접근할 수 있습니다. 예를 들어 a[0], a[1], a[2] 등입니다.

배열은 매우 효율적이기 때문에 널리 사용됩니다.

== 배열의 속성

다음은 자바에서 배열의 주요 속성입니다:

1.	배열은 객체입니다.
2.	배열은 동적으로 생성됩니다 (실행 시간에).
3.	배열은 Object 형식의 변수에 할당될 수 있습니다.
4.	Object 클래스의 모든 메서드를 배열에서 호출할 수 있습니다.
5.	배열 객체에는 변수의 연속이 포함되어 있습니다.
6.	이러한 변수를 배열의 구성 요소 또는 요소라고 합니다.
7.	구성 요소 유형이 T이면 배열 자체의 유형은 T[]입니다.
8.	배열 유형 변수는 배열 객체에 대한 참조를 보유합니다.
9.	구성 요소 유형 자체가 배열 유형 일 수 있습니다.
10.	배열 요소는 배열 유형이 아닌 구성 요소입니다.
11.	요소의 유형은 기본 유형 또는 참조 일 수 있습니다.
12.	배열의 길이는 해당 구성 요소의 수입니다.
13.	배열의 길이는 배열이 생성될 때 설정되며 변경할 수 없습니다.
14.	배열의 길이는 public final 인스턴스 변수로 액세스할 수 있습니다.
15.	배열 인덱스 값은 0...length - 1 범위의 정수여야 합니다.
16.	속성 15가 위배되면 ArrayIndexOutOfBoundsException이 발생합니다.
17.	short, byte 또는 char 유형의 변수를 인덱스로 사용할 수 있습니다.
18.	Object.clone() 메서드를 사용하여 배열을 복제할 수 있습니다.
19.	Arrays.equals() 메서드를 사용하여 배열의 동등성을 테스트할 수 있습니다.
20.	배열 객체는 Cloneable 및 java.io.Serializable를 구현합니다.

속성 3은 속성 1로부터 따릅니다. 배열 유형은 클래스가 아니지만 Object 클래스의 확장으로 작동합니다. 속성 7은 배열 유형이 클래스 유형과 동일하지 않음을 보여줍니다. 실제로 배열 유형은 유도 유형입니다: 모든 클래스 유형 T에 대해 해당하는 배열 유형 T[]가 있습니다. 또한 각각의 여덟 가지 기본 유형에 대해 해당하는 배열 유형이 존재합니다.

속성 9는 배열의 배열의 존재를 허용합니다. 기술적으로 자바는 기본 유형의 다차원 배열 만 허용합니다. 그러나 객체에 대해서는 배열의 배열이 본질적으로 동일합니다. 배열 자체가 객체이므로 배열의 배열은 객체의 배열이며 이러한 구성 요소 객체 중 일부는 비 배열 일 수도 있습니다. (예: 예제 2.1 참조)

속성 13의 결과로 null을 참조 구성 요소 값으로 변경해도 배열의 길이에는 영향을 미치지 않습니다. null은 여전히 참조 구성 요소의 유효한 값입니다.

=== EXAMPLE 2.1 Some Array Definitions

배열 정의는 아래와 같습니다.

[source,java]
----
1	public class ArrayDefs {
2	    public static void main(String[] args) {
3	        float x[];
4	        x = new float[100];
5	        args = new String[10];
6	        boolean[] isPrime = new boolean[1000];
7	        int fib[] = {0, 1, 1, 2, 3, 5, 8, 13};
8	        short[][][] b = new short[4][10][5];
9	        double a[][] = {{1.1,2.2}, {3.3,4.4}, null, {5.5,6.6}, null};
10	        a[4] = new double[66];
11	        a[4][65] = 3.14;
12	        Object[] objects = {x, args, isPrime, fib, b, a};
13	    }
14	}
----

3번 줄에서는 x[]를 float의 배열로 선언하지만 배열에 대한 저장 공간을 할당하지 않습니다. 4번 줄에서는 x[]가 100개의 float 구성 요소를 가지도록 정의합니다.

5번 줄에서는 args[]를 10개의 String 객체로 이루어진 배열로 선언합니다. 배열을 선언하는 두 가지 다른 (동등한) 방법에 주목하세요: 대괄호는 유형 식별자 또는 배열 식별자의 접미사로 사용될 수 있습니다. 5번 줄에서는 args[]가 10개의 String 구성 요소를 가지도록 정의합니다.

6번 줄에서는 isPrime[]를 1000개의 boolean 변수로 이루어진 배열로 정의합니다.

7번 줄에서는 fib[]를 8개의 int로 이루어진 배열로 정의하고, 그 값은 나열된 8개의 값으로 초기화합니다. 예를 들어, fib[4]는 값 3을 가지며, fib[7]은 값 13을 가집니다.

8번 줄에서는 b[][][]를 4개의 구성 요소로 이루어진 3차원 배열로 정의합니다. 각 구성 요소는 10개의 구성 요소로 이루어진 2차원 배열이고, 각각은 short 형식의 5개의 구성 요소 요소로 이루어진 1차원 배열입니다.

9번 줄에서는 a[][]를 double 형식의 요소로 이루어진 배열로 정의합니다. 다섯 개의 구성 요소 배열 중에서는 세 개만 할당됩니다. 그런 다음 10번 줄에서는 a[4]에 66개의 double 요소로 이루어진 배열을 할당하고, 11번 줄에서는 그 마지막 요소에 3.14를 할당합니다.

12번 줄에서는 배열 객체가 여섯 개의 구성 요소로 이루어져 있음을 정의합니다. 이 중 첫 네 개의 구성 요소 배열의 구성 요소는 요소 (비 배열)입니다. 그러나 b와 a의 구성 요소는 배열이기 때문에 요소가 아닙니다. 객체 배열의 실제 요소에는 2, 5 및 13(fib 구성 요소의 구성 요소), null(a 구성 요소의 구성 요소), 그리고 2.2 및 3.14(a 구성 요소의 구성 요소)가 포함됩니다.

예제 2.1에서 정의된 배열 a[][]는 서로 다른 길이의 행을 가진 이차원 배열이기 때문에 불균일한 배열이라고 합니다.
자바에서 배열의 요소 유형은 기본 유형, 참조 유형 또는 배열 유형이 될 수 있습니다. 가장 간단한 것은 예제 2.1의 x[], isPrime[], fib[]와 같이 기본 유형 요소의 배열입니다. 이러한 배열은 정렬될 수 있는 배열입니다.

== 배열 복제

배열은 객체이기 때문에 Example 2.2에서 보여진 것처럼 Object.clone() 메서드를 호출하여 복제할 수 있습니다.

=== 예제 2.2 배열 복제


[source,java]
----
15	public class DuplicatingArrays {
16	    public static void main(String[] args) {
17	        int[] a = {22, 44, 66, 88};
18	        print(a);
19	        int[] b = (int[])a.clone(); // duplicate a[] in b[]
20	        print(b);
21	        String[] c = {"AB", "CD", "EF"};
22	        print(c);
23	        String[] d = (String[])c.clone(); // duplicate c[] in d[]
24	        print(d);
25	        c[1] = "XYZ"; // change c[], but not d[]
26	        print(c);
27	        print(d);
28	    }
29
30	    public static void print(int[] a) {
31	        System.out.printf("{%d", a[0]);
32	        for (int i = 1; i < a.length; i++) {
33	            System.out.printf(", %d", a[i]);
34	        }
35	        System.out.println("}");
36	    }
37
38	    public static void print(Object[] a) {
39	        System.out.printf("{%s", a[0]);
40	        for (int i = 1; i < a.length; i++) {
41	            System.out.printf(", %s", a[i]);
42	        }
43	        System.out.println("}");
44	    }
45	}
----

The output is:

[source,console]
----
{22, 44, 66, 88}
{22, 44, 66, 88}
{AB, CD, EF}
{AB, CD, EF}
{AB, XYZ, EF}
{AB, CD, EF}
----

배열 a[]에는 네 개의 int 요소가 포함되어 있습니다. 배열 b[]는 a[]의 복제본입니다. 마찬가지로, 배열 d[]는 각각 세 개의 String 요소를 포함하는 배열 c[]의 복제본입니다. 두 경우 모두 복제는 clone() 메서드를 호출하여 얻습니다. 이 메서드는 Object에 대한 참조를 반환하므로 복제되는 배열 유형, int[] 또는 String[]로 캐스트해야 합니다.

예제의 마지막 부분에서 복제된 배열 d[]가 실제로 c[]의 별도 복사본임을 보여줍니다: c[1]을 "XYZ"로 변경하면 d[1]의 값 "CD"에는 영향을 주지 않습니다.


=== java.util.Arrays 클래스

자바에는 배열을 처리하기 위한 특별한 "유틸리티" 클래스가 포함되어 있습니다. 이 클래스의 이름은 Arrays이며 java.util 패키지에 정의되어 있습니다.

=== 예제 2.3 java.util.Arrays 클래스 사용

이 프로그램은 java.util 패키지의 Arrays 클래스를 가져와 sort(), binarySearch(), fill(), equals() 메서드에 액세스합니다. 또한 예제 2.2에서의 static print() 메서드를 가져옵니다.


[source,java]
----
1	import java.util.Arrays;
2
3	public class TestArrays {
4	    public static void main(String[] args) {
5	        int[] a = {44, 77, 55, 22, 99, 88, 33, 66};
6	        print(a);
7	        Arrays.sort(a);
8	        print(a);
9	        int k = Arrays.binarySearch(a, 44);
10	        System.out.printf("Arrays.binarySearch(a, 44): %d%n", k);
11	        System.out.printf("a[%d]: %d%n", k, a[k]);
12	        k = Arrays.binarySearch(a, 45);
13	        System.out.printf("Arrays.binarySearch(a, 45): %d%n", k);
14	        int[] b = new int[8];
15	        print(b);
16	        Arrays.fill(b, 55);
17	        print(b);
18	        System.out.println("Arrays.equals(a,b): " + Arrays.equals(a,b));
19	    }
20	}
----

The output is

[source,console]
----
44 77 55 22 99 88 33 66
22 33 44 55 66 77 88 99
Arrays.binarySearch(a, 44): 2
a[2]: 44
Arrays.binarySearch(a, 45): -4
0 0 0 0 0 0 0 0
55 55 55 55 55 55 55 55
Arrays.equals(a,b): false
----

배열 a[]는 5–6번 줄에서 생성되고 출력됩니다. 7번 줄에서는 Arrays.sort(a) 호출로 배열의 요소를 정렬하여 오름차순으로 정렬합니다. 이를 8번 줄의 출력에서 확인할 수 있습니다.

9번 줄에서 Arrays.binarySearch() 메서드가 호출됩니다. 두 번째 인수인 44는 검색 대상입니다. 메서드는 인덱스 2를 반환하며, 이를 9번 줄에서 k에 할당합니다. 11번 줄에서 44가 실제로 a[2]의 값인지 확인합니다.

메서드는 13번 줄에서 다시 호출되며, 이번에는 대상을 45로 검색합니다. 배열에서 해당 값이 발견되지 않으므로 메서드는 음수 값을 반환하며, k = -4가 됩니다. 이렇게 되면 인덱스 i = -k - 1이 배열에 대상 요소를 삽입하여 배열의 오름차순을 유지해야하는 위치가 됩니다. 이 경우에는 i = -k - 1 = 3이며, 45는 배열에 45보다 작은 세 개의 요소가 있기 때문에 a[3]에 삽입되어야 합니다.

17번 줄의 출력은 Arrays.fill() 메서드가 어떻게 작동하는지 보여줍니다: 8개의 요소 배열 b[]를 인수 55로 채웁니다.

마지막으로, 18번 줄에서 Arrays.equals() 메서드가 어떻게 작동하는지 보여줍니다. 이 메서드는 두 배열이 같은 요소 유형(예: a[]와 b[]의 경우 int[])을 가지고 있고, 같은 길이(예: a[]와 b[]의 경우 8)를 가지며, 각 요소에서 같은 값을 가질 때만 true를 반환합니다(a[]와 b[]는 그렇지 않습니다).

자바의 java.util.Arrays 클래스에 대한 자세한 내용은 페이지 95에 개요가 나와 있습니다.


== 순차 검색 알고리즘

_순차 검색_ (또는 _선형 검색_이라고도 함)은 가장 간단한 검색 알고리즘입니다. 또한 가장 효율성이 낮습니다. 이 알고리즘은 각 요소를 처음부터 순차적으로 검사하여 키 요소를 찾거나 배열의 끝에 도달할 때까지 계속합니다.

움직이는 승객 열차에서 누군가를 찾고 있다면 순차 검색을 사용할 것입니다.

다음은 _순차 검색 알고리즘_입니다:

(사후 조건: si = x인 인덱스 i가 반환되거나 -1이 반환됩니다.)

1.	i가 0부터 n - 1까지 반복하면서 단계 2-3을 반복합니다.
2.	(불변: 부분 시퀀스 stem:[\{s_{0}...s_{i-1}\}]에 있는 요소는 모두 x와 같지 않습니다.)
3.	stem:[s_{i} = x]인 경우 i를 반환합니다.
4.	-1을 반환합니다.

이 알고리즘은 예제 2.4에서 구현되었습니다.


=== EXAMPLE 2.4 The Sequential Search

[source,java]
----
1	public class TestBinarySearch {
2	    public static void main(String[] args) {
3	        int[] a = {22, 33, 44, 55, 66, 77, 88, 99};
4	        ch02.ex02.DuplicatingArrays.print(a);
5	        System.out.println("search(a, 44): " + search(a, 44));
6	        System.out.println("search(a, 50): " + search(a, 50));
7	        System.out.println("search(a, 77): " + search(a, 77));
8	        System.out.println("search(a, 100): " + search(a, 100));
9	    }
10
11	    public static int search(int[] a, int x) {
12	        // POSTCONDITIONS: returns an integer i;
13	        //	if i >= 0, then a[i] == x; otherwise x is not in a[];
14	        for (int i=0; i<a.length; i++) {	// step 1
15	            // INVARIANT: x is not among a[0]...a[i-1] // step 2
16	            if (a[i] == x) {	// step 3
17	                return i;
18	            }
19	        }
20	        return -1;	// step 4
21	    }
22	}
----

The output is:

[source,console]
----
{22, 33, 44, 55, 66, 77, 88, 99}
search(a, 44): 2
search(a, 50): -1
search(a, 77): 5
search(a, 100): -1
----

search() 메서드는 대상 x의 인덱스를 반환합니다. search(a, 44)는 a[2] = 44이므로 2를 반환합니다. search(a, 77)는 a[5] = 77이므로 5를 반환합니다. 대상이 배열에 없는 경우 메서드는 -1을 반환합니다. search(a, 50)은 50이 배열에 없으므로 -1을 반환합니다.

**순차 검색은 올바릅니다**. 즉, 작동합니다. 다음의 주장은 이 사실을 입증한 것입니다.

만약 n = 0이라면, 시퀀스는 비어 있으며 루프는 전혀 실행되지 않습니다. 단계 4만 실행되며 즉시 -1을 반환합니다. 이는 사후 조건을 만족합니다: 요소가 없기 때문에 x는 어떤 요소와도 같을 수 없습니다.

만약 n = 1이라면, 루프는 한 번만 반복되며 i = 0입니다. 그 반복에서 stem:[s_{0} = x] 또는 stem:[s_{0} \neq x]입니다. stem:[s_{0} = x]인 경우 0이 반환되고 사후 조건이 만족됩니다. stem:[s_{0} \neq x]인 경우 루프가 종료되고 단계 4가 실행되어 -1이 반환되며, 이는 시퀀스의 단일 요소가 x와 같지 않기 때문에 사후 조건을 만족합니다.

이제 n > 1인 경우를 가정해 봅시다. 우리는 수학적 귀납법의 첫 번째 원리를 적용하여 루프의 각 반복에서 루프 불변식이 참임을 추론해야 합니다. (참조: 페이지 321.) 이것은 첫 번째 반복에서 불변식을 확인하고, i번째 반복에서 불변식을 i – 1번째 반복에서의 불변식에서 추론하는 것을 요구합니다.

루프의 첫 번째 반복에서 i = 0이고, 단계 2의 루프 불변식이 "공집합"인 부분 수열에서 참입니다. 그런 다음 단계 3에서는 stem:[s_{0} = x] 또는 stem:[s_{0} \neq x]입니다. stem:[s_{0} = x]인 경우 0이 반환되고 사후 조건이 만족됩니다. stem:[s_{0} \neq x\]인 경우 루프가 두 번째 반복으로 이어집니다. 이제 i = 1이고, 단계 2의 루프 불변식이 참입니다. 왜냐하면 부분 수열 stem:[\{s_{0}...s_{i–1}\} = \{s_{0}\}]이고 s_{0} ≠ x이기 때문입니다.

이제 i – 1번째 반복에서 루프 불변식이 참임을 가정해 봅시다; 즉, 부분 수열 stem:[\{s_{0} \cdots s_{i-1}\}]에 있는 요소 중 어느 것도 x와 같지 않습니다. 루프가 다음 반복으로 이어지면, 그럼 단계 3에서의 stem:[s_{i} = x] 조건은 참이 아니었습니다. 따라서 stem:[s_{i} ≠ x]입니다. 따라서 부분 수열 stem:[\{s_{0} \cdots s_{i} \}]에 있는 요소 중 어느 것도 x와 같지 않으므로 이것이 부분 수열 stem:[i]번째 반복에서의 루프 불변식입니다.

순차 검색은 stem:[O(n)] 시간이 걸립니다. 이것은 평균적으로 실행 시간이 배열의 요소 수에 비례한다는 것을 의미합니다. 따라서 다른 모든 것이 동일한 경우 배열을 두 배로 길게 만들어 순차 검색을 적용하면 평균적으로 시간이 두 배가 걸릴 것입니다. 다음은 이 사실을 입증한 것입니다.
만약 x가 시퀀스에 있다면, 즉 stem:[x = s_{i}]이고 i < n이면, 루프가 i번 반복됩니다. 이 경우 실행 시간은 i에 비례하며, i < n이므로 stem:[O(n)]입니다. x가 시퀀스에 없으면 루프가 n번 반복되며, 이는 실행 시간이 n에 비례하므로 stem:[O(n)]입니다.

== 이진 검색 알고리즘

이진 검색은 정렬된 시퀀스를 검색하는 표준 알고리즘입니다. 순차 검색보다 훨씬 효율적이지만 요소가 정렬되어 있어야 합니다. 이 알고리즘은 시퀀스를 반으로 나누어 매번 요소를 포함할 것으로 예상되는 절반으로 검색 범위를 제한합니다.

사전에서 단어를 찾을 때 이진 검색을 사용할 수 있습니다. 다음은 바이너리 알고리즘입니다:

(전제 조건: stem:[s = \{s_{0}, s_{1}, \cdots, s_{n-1}\}]은 x와 동일한 유형의 n개의 값으로 구성된 정렬된 시퀀스입니다.)
(사후 조건: 인덱스 i가 반환되어야 할 stem:[s_{i} = x]가 있는 경우, 또는 -1이 반환됩니다.)

1.	ss를 시퀀스 s의 부분 시퀀스로 정의하고, 초기에 ss를 s와 동일하게 설정합니다.
2.	부분 시퀀스 ss가 비어 있다면, -1을 반환합니다.
3.	(불변식: x가 시퀀스 s에 있다면, 그것은 부분 시퀀스 ss에 있어야 합니다.)
4.	si를 ss의 중간 요소로 설정합니다.
5.	si가 x와 같다면, 해당하는 인덱스 i를 반환합니다.
6.	si가 x보다 작다면, stem:[s_i] 위에 있는 부분 시퀀스에 대해 단계 2-7을 반복합니다.
7.	ss의 하위에 있는 si에 대한 부분 시퀀스에 대해 단계 2-7을 반복합니다. 이것은 예제 2.5에서 구현되었습니다.


=== EXAMPLE 2.5 The Binary Search

[source,java]
----
1	public class TestBinarySearch {
2	    public static void main(String[] args) {
3	        int[] a = {22, 33, 44, 55, 66, 77, 88, 99};
4	        ch02.ex02.DuplicatingArrays.print(a);
5	        System.out.println("search(a, 44): " + search(a, 44));
6	        System.out.println("search(a, 50): " + search(a, 50));
7	        System.out.println("search(a, 77): " + search(a, 77));
8	        System.out.println("search(a, 100): " + search(a, 100));
9	    }
10
11	    public static int search(int[] a, int x) {
12	        // POSTCONDITIONS: returns i;
13	        //	if i >= 0, then a[i] == x; otherwise i == -1;
14	        int lo = 0;
15	        int hi = a.length;
16	        while (lo < hi) {	        // step 1
17	            // INVARIANT: if a[j]==x then lo <= j < hi; // step 3
18	            int i = (lo + hi)/2;	// step 4
19	            if (a[i] == x) {
20	                return i;	        // step 5
21	            } else if (a[i] < x) {
22	                lo = i+1;	        // step 6
23	            } else {
24	                hi = i;	            // step 7
25	            }
26	        }
27	        return -1;	                // step 2
28	    }
29	}
----

출력은 예제 2.4와 동일합니다.

이진 검색은 올바릅니다. 루프 불변식은 첫 번째 반복에서 참입니다. 왜냐하면 현재 부분 시퀀스는 원래 시퀀스와 동일하기 때문입니다. 다른 모든 반복에서는 현재 부분 시퀀스가 이전 부분 시퀀스의 절반이며, 그 중에 x를 포함하지 않는 절반이 생략된 후 남은 부분입니다. 따라서 원래 시퀀스에 x가 있으면 현재 부분 시퀀스에도 있어야 합니다. 따라서 루프 불변식은 모든 반복에서 참입니다.

각 반복에서 si = x인 경우 i가 반환되거나 부분 시퀀스가 50% 이상으로 줄어듭니다. 원래 시퀀스에는 유한 개의 요소만 있으므로 루프는 무한정 계속될 수 없습니다. 따라서 알고리즘은 루프 내에서 i를 반환하거나 부분 시퀀스가 비어 있는 경우인 단계 6 또는 단계 7에서 –1을 반환하여 종료됩니다. 루프 내에서 i가 반환되면 stem:[s_{i} = x]입니다. 그렇지 않으면 하위가 lo보다 작을 때 루프가 종료됩니다. 즉, 부분 시퀀스가 비어 있는 경우입니다. 이 경우 루프 불변식에 따라 원래 시퀀스에 si가 없음을 알 수 있습니다.

이진 검색은 stem:[O(\lg n)] 시간이 걸립니다. 이것은 평균적으로 실행 시간이 배열의 요소 수의 로그에 비례한다는 것을 의미합니다. 따라서 다른 모든 것이 동일한 경우, 요소 수가 n인 배열에서 평균 T 밀리초가 걸린다면, stem:[n^{2}] 요소의 배열에서 평균 2T 밀리초가 걸릴 것입니다. 예를 들어, 1만 개의 요소를 검색하는 데 3 ms가 걸린다면, 1억 개의 요소를 검색하는 데는 약 6 ms가 걸릴 것입니다! 다음의 주장은 이 사실을 입증한 것입니다.

루프의 각 반복은 이전 반복에서의 부분 배열의 절반보다 짧습니다. 따라서 총 반복 횟수는 길이 n이 2로 나눌 수 있는 횟수보다 많지 않습니다. 그 숫자는 lg n입니다. 또한 총 실행 시간은 대략 루프가 수행하는 반복 횟수에 비례합니다.

== 복습 문제

1. 배열의 구성요소(component)와 요소(element)의 차이는 무엇인가요?
2. 자바가 다차원 배열을 허용하지 않는다는 것은 무엇을 의미하나요?
3. ArrayIndexOutOfBoundsException 예외는 무엇이고, 그 사용 방법은 C나 C++과 같은 다른 언어와 어떻게 다른가요?
4. 배열 인덱스에 대해 유효한 타입은 무엇인가요?
5. 다음 정의에 무엇이 잘못되었나요:
   Arrays arrays = new Arrays();
6. 객체 배열을 출력하는 가장 간단한 방법은 무엇인가요?
7. 이진 검색이 순차 검색보다 훨씬 빠르다면, 후자가 언제 사용될까요?
8. 배열에서 두 번 이상 발생하는 요소에 순차 검색이 적용된다면 어떻게 될까요?
9. 배열에서 두 번 이상 발생하는 요소에 이진 검색이 적용된다면 어떻게 될까요?

== 문제들

1. 배열의 fill() 메서드가 객체 배열을 어떻게 처리하는지 보기 위해 테스트 프로그램을 실행하세요.
2. 순차 검색이 10,000개 요소 배열에서 실행하는데 50ms가 걸렸다면, 동일한 컴퓨터에서 20,000개 요소 배열에서는 얼마나 걸릴 것으로 예상합니까?
3. 이진 검색이 1,000개 요소 배열에서 실행하는데 5ms가 걸렸다면, 동일한 컴퓨터에서 1,000,000개 요소 배열에서는 얼마나 걸릴 것으로 예상합니까?
4. 보간 검색(interpolation search)은 이진 검색과 동일하지만, 4단계에서 요소 stem:[s_{i}]는 ss 서열에서 stem:[s_{i}]보다 작은 요소의 비율이 균등 분포에서 예상되는 비율과 같도록 선택됩니다. +
예를 들어, 2,600페이지의 전화번호부에서 “Byrd”라는 이름을 찾을 때, 약 2/26의 이름이 그 앞에 있을 것으로 예상하여 처음에는 200페이지 근처를 엽니다. +
보간 검색은 stem:[O(\lg(\lg n))] 시간에 실행되는 것으로 보여집니다. 1,000개 요소 배열에서 실행하는데 5ms가 걸렸다면, 동일한 컴퓨터에서 1,000,000개 요소 배열에서는 얼마나 걸릴 것으로 예상합니까?
5. 10,000개 요소 배열에서 이진 검색 메서드에 대한 테스트를 실행하고 반복 횟수를 계산하세요.
6. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
boolean isSorted(int[] a)
// 배열 a[0] <= a[1] <= ... <= a[a.length-1] 이면 true를 반환합니다.
----
7. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
int minimum(int[] a)
// 배열 a[]의 최소 요소를 반환합니다.
----
8. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
double mean(double[] a)
// 배열 a[]의 모든 요소의 평균 값을 반환합니다.
----
9. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
int[] withoutDuplicates(int[] a)
// 중복을 제거한 배열을 반환합니다.
----
10. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
void reverse(int[] a)
// 배열의 요소를 뒤집습니다.
----
11. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
Object[] concatenate(Object[] a, Object[] b)
// 배열 a[]와 b[]의 모든 요소를 포함하는 배열을 반환합니다.
----
12. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
void shuffle(Object[] a)
// 배열의 요소를 무작위로 섞습니다.
----
13. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
int[] tally(String string)
// 주어진 문자열에서 대소문자 구분 없이 문자 빈도를 계산한 26개의 정수 배열을 반환합니다.
----
14. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
double innerProduct(double[] x, double[] y)
// 두 배열의 대수적 내적을 반환합니다. (각 요소의 곱의 합)
----
15. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
double[][] outerProduct(double[] x, double[] y)
// 두 배열의 대수적 외적을 반환합니다: p[i][j] = a[i]*b[j]
----
16. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
double[][] product(double[][] a, double[][] b)
// 두 배열의 행렬 곱을 반환합니다: p[i][j] = Sum(a[i][k]*b[k][j]:k)
----
17. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
double[][] transpose(double[][] a)
// 주어진 배열의 전치 행렬을 반환합니다: ta[i][j] = a[j][i]
----
18. 다음 메서드를 작성하고 테스트하세요:
+
[source,java]
----
int[][] pascal(int size)
// 주어진 크기의 파스칼 삼각형을 반환합니다.
----
19. 에라토스테네스의 체는 i번째 요소가 소수일 때만 true인 boolean 요소의 배열입니다. 다음 알고리즘을 사용하여 크기 1000의 체를 계산하고 출력하세요: +
(전제 조건: p는 n 비트 배열입니다.) +
(사후 조건: p[i]는 i가 소수일 때만 true입니다.) +
. p[0]과 p[1]을 false로 초기화하고, 다른 모든 p[i]는 true로 초기화합니다.
. 3부터 n까지 각 i에 대해 2씩 증가하며 3단계를 반복합니다.
. i를 나누는 제곱근 이하의 소수가 있으면 p[i]를 false로 설정합니다.
20. 문제 2.19를 java.util.Vector 객체를 사용하여 반복하세요.
21. 문제 2.19를 java.util.BitSet 객체를 사용하여 반복하세요.
22. 다음 메서드가 있는 Primes 클래스를 정의하고 테스트하세요:
+
[source,java]
----
public static void setLast(int last)	// last 설정
public static void setLast()	// last를 1로 설정
public static void sizeSize(int size) // 비트셋 크기 설정
public static void sizeSize()	// 비트셋 크기를 1000으로 설정
public static boolean isPrime(int n)	// n이 소수이면 true
public static int next()	// last 이후의 다음 소수
public static void printPrimes()	// 체를 출력
----
에라토스테네스의 체의 BitSet 구현을 문제 2.21에서 사용하세요. 다음 정의를 사용하세요:
+
[source,java]
----
public class Primes {
    private static final int SIZE = 1000;
    private static int size = SIZE;
    private static BitSet sieve = new BitSet(size);
    private static int last = 1;
----
다음과 같은 정적 초기화 블록을 포함하여 에라토스테네스의 체를 구현합니다:
+
[source,java]
----
static {
    for (int i = 2; i < SIZE; i++) {
        sieve.set(i);
    }
    for (int n = 2; 2*n < SIZE; n++) {
        if (sieve.get(n)) {
            for (int m=n; m*n<SIZE; m++) {
                sieve.clear(m*n);
            }
        }
    }
}
----
23. 다음 메서드를 Primes 클래스에 추가하고 테스트하세요:
+
[source,java]
----
public static String factor(int n)
// 전제 조건: n > 1
// n의 소인수 분해를 반환합니다;
// 예: factor(4840)은 "2*2*2*5*11*11"을 반환합니다.
----
24. Christian Goldbach(1690–1764)는 1742년에 2보다 큰 모든 짝수는 두 소수의 합으로 표현된다고 추측했습니다. 문제 2.22의 Primes 클래스를 사용하여 100 이하의 모든 짝수에 대해 골드바흐 추측을 테스트하는 프로그램을 작성하세요. 첫 10줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
4 = 2+2
6 = 3+3
8 = 3+5
10 = 3+7 = 5+5
12 = 5+7
14 = 3+11 = 7+7
16 = 3+13 = 5+11
18 = 5+13 = 7+11
20 = 3+17 = 7+13
22 = 3+19 = 5+17 = 11+11
----
25. Pierre de Fermat(1601–1665)는 어떤 정수 p에 대해 n = 2^{2^{p}}+1 형태의 소수가 무한히 많다고 추측했습니다. 이러한 수를 Fermat 소수라고 합니다. 예를 들어, 5는 소수이고 2^{2^{1}} + 1 형태이므로 Fermat 소수입니다. 문제 2.22의 Primes 클래스를 사용하여 int 타입의 범위 내에서 모든 Fermat 소수를 찾는 프로그램을 작성하세요. 첫 5줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
2^0 + 1 = 3
2^1 + 1 = 5
2^2 + 1 = 17
2^3 + 1 = 257
2^4 + 1 = 65537
----
26. Charles Babbage(1792–1871)는 1823년에 정부 보조금을 처음으로 받아내어 차분 기관을 만들기 위해 £1000를 받았습니다. 그의 보조금 제안서에서, Babbage는 그의 컴퓨터가 x^2 + x + 41 공식을 표로 작성할 것이라고 예를 들었습니다. 이 함수는 많은 소수를 생성하기 때문에 수학자들에게 흥미로웠습니다. n = x^2 + x + 41 형태의 소수를 Babbage 소수라고 할 수 있습니다. 문제 2.22의 Primes 클래스를 사용하여 10,000 미만의 모든 Babbage 소수를 찾는 프로그램을 작성하세요. 첫 5 줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
0 41 is prime
1 43 is prime
2 47 is prime
3 53 is prime
4 61 is prime
----
27. 두 연속된 홀수가 모두 소수일 때, 이를 쌍둥이 소수라고 합니다. 쌍둥이 소수 추측은 쌍둥이 소수가 무한히 많다는 것입니다. 문제 2.22의 Primes 클래스를 사용하여 1000 미만의 모든 쌍둥이 소수를 찾는 프로그램을 작성하세요. 첫 5줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
3 5
5 7
11 13
17 19
29 31
----
28. 각 연속된 제곱수 쌍 사이에 적어도 하나의 소수가 있다는 가설을 테스트하세요. (제곱수는 1, 4, 9, 16, 25, ...입니다). 문제 2.22의 Primes 클래스를 사용하세요. 첫 5줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
1 < 2 < 4
4 < 5 < 9
9 < 11 < 16
16 < 17 < 25
25 < 29 < 36
----
29. Minimite 수도사 Marin Mersenne(1588–1648)는 p가 소수일 때 n = 2^p - 1 형태의 수를 연구했습니다. 그는 대부분의 n이 소수일 것이라고 믿었습니다. 이제 이 수는 Mersenne 소수라고 합니다. 문제 2.22의 Primes 클래스를 사용하여 p < 30인 모든 Mersenne 소수를 찾는 프로그램을 작성하세요. 첫 5줄의 출력은 다음과 같아야 합니다:
+
[source,console]
----
2^2-1 = 3 is prime
3 2^3-1 = 7 is prime
5 2^5-1 = 31 is prime
7 2^7-1 = 127 is prime
11 2^11-1 = 2047 is not prime
----
30. 숫자가 뒤집혀도 동일할 때, 그 숫자를 회문이라고 합니다. 예를 들어, 3456543은 회문입니다. 문제 2.22의 Primes 클래스를 사용하여 처음 10,000개의 소수를 검사하고 회문인 소수를 출력하는 프로그램을 작성하세요.